# -*- coding: utf-8 -*-
"""Copy of Analysis_IS_OS_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S6xTbLd9lh5_YFVPUqSi3pUyKLFwiOir
"""

# Commented out IPython magic to ensure Python compatibility.
# std libraries
import numpy as np
import pandas as pd
import sys
# sys.path.append(r'C:\Users\Rae-Djamaal\Anaconda3\Lib\Git_Uploads\chameleon_project_phase1_Final\Phase_1')

# vizualization and mapping modules
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
from mpl_toolkits.basemap import Basemap
import geopandas as gpd
from shapely.geometry import Point, LineString, mapping
from sklearn.neighbors import BallTree
from bokeh.io import output_notebook,show
from bokeh.models import GeoJSONDataSource


# User Defined modules
from nneigh.nneigh import nearest_neighbor
from SQL_Mods.sql_mods import MySQL_Operations

"""Connect to MySQL Server"""

# Call the instance MySQL Class
db_call_2 = MySQL_Operations('propeladmin','pS4bmwAKuaGZN9Xx!','54.86.38.255','route_risk')

# check the engine
print(db_call_2.Engine_Connection()[0])

# check the connection
print(db_call_2.Database_Connection()[0])

# get the connection object
connection = db_call_2.Database_Connection()[1]

# Create the cursor
cursor = connection.cursor(prepared=True)

# get the engine object
engine = db_call_2.Database_Connection()[1]

# Load IN Service Carriers
Clean_IS = pd.read_sql('SELECT * FROM IS_Geocord_With_Address', con=engine)
Clean_IS.shape

# Load OOS Carriers
Clean_OS_Carr = pd.read_sql('SELECT * FROM oos_company_coordinates', con=engine)
Clean_OS_Carr.shape

# Create Points Objects for both dataframes
points = Clean_OS_Carr.apply(lambda row: Point(row.LON, row.LAT), axis = 1)
points1 = Clean_IS.apply(lambda row: Point(row.LON, row.LAT), axis = 1)

# Convert OOS Carriers to GeoDFs
Clean_OS_Carr_Gdf = gpd.GeoDataFrame(Clean_OS_Carr,geometry = points)
# Specify the coordinate ref system
Clean_OS_Carr_Gdf.crs = {'init':'epsg:4326'}
# Check the shape of the df
print(Clean_OS_Carr_Gdf.shape)

# Convert IS Carriers to GeoDF
Cl_STATE_Gdf = gpd.GeoDataFrame(Clean_IS,geometry = points1)
# Specify the coordinate ref system
Cl_STATE_Gdf.crs = {'init':'epsg:4326'}
print(Cl_STATE_Gdf.shape)

# Drop Missing LAT and LONGS
#Clean_OS_Carr_Gdf.isna().any()
Clean_OS_Gdf= Clean_OS_Carr_Gdf.dropna(subset=['LAT'])
Clean_OS_Gdf.reset_index(drop=True, inplace=True)
len(Clean_OS_Gdf)

# Apply the KNN Function
closest_IS_All = nearest_neighbor(Cl_STATE_Gdf,Clean_OS_Gdf, return_dist=True)

closest_IS_All.shape

# Merge the datasets by index (for this, it is good to use '.join()' -function)
Merge_Closest = Cl_STATE_Gdf.join(closest_IS_All ,lsuffix='_IS', rsuffix='_OS')
Merge_Closest.shape

# Convert Geodataframe to Dataframe
KNN_Dist = pd.DataFrame(Merge_Closest)
KNN_Distance = KNN_Dist[['LEGAL_NAME_OS',	'STATE_OS',	'USDOT_IS','distance in meters_1']]

# create the engine object
engine1 = create_engine('mysql+mysqlconnector://enter_your_user:enter_your_password@enter_your_host/enter_your_database')
# Save the KNN_Dist to MySQL Server
KNN_Distance.to_sql('KNN_Distance', engine1, if_exists='replace', index=False)